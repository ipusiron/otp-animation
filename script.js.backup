// ãƒ†ã‚­ã‚¹ãƒˆã‚’8bitå˜ä½ã§ãƒ“ãƒƒãƒˆåˆ—ï¼ˆé…åˆ—ï¼‰ã«å¤‰æ›
function textToBits(text) {
  return text
    .split('')
    .map(c => c.charCodeAt(0).toString(2).padStart(8, '0'))
    .join('')
    .split('')
    .map(bit => parseInt(bit));
}

// ãƒ“ãƒƒãƒˆåˆ—å¤‰æ› + ä¸æ­£æ–‡å­—ãƒã‚§ãƒƒã‚¯
function textToBitsWithValidation(text) {
  const bits = [];
  let invalidChar = null;

  for (const char of text) {
    const code = char.codePointAt(0);

    if (code < 32 || code > 126) {
      invalidChar = char;
      break;
    }

    const bin = code.toString(2).padStart(8, '0');
    bin.split('').forEach(bit => bits.push(Number(bit)));
  }

  return { bits, invalidChar };
}

// ãƒ“ãƒƒãƒˆåˆ—ã‚’ãƒ†ã‚­ã‚¹ãƒˆã«å¤‰æ›
function bitsToText(bits) {
  let text = '';
  for (let i = 0; i < bits.length; i += 8) {
    const byte = bits.slice(i, i + 8).join('');
    const charCode = parseInt(byte, 2);
    text += String.fromCharCode(charCode);
  }
  return text;
}

// æŒ‡å®šé•·ã®ãƒ©ãƒ³ãƒ€ãƒ ãƒ“ãƒƒãƒˆåˆ—ï¼ˆéµï¼‰ã‚’ç”Ÿæˆ
function generateRandomBits(length) {
  return Array.from({ length }, () => Math.round(Math.random()));
}

// XORå‡¦ç†ï¼ˆãƒ“ãƒƒãƒˆå˜ä½ï¼‰
function xorBits(bits1, bits2) {
  return bits1.map((bit, i) => bit ^ bits2[i]);
}

// å„ãƒ“ãƒƒãƒˆã‚’ç”»é¢ã«æç”»ï¼ˆ8ãƒ“ãƒƒãƒˆã‚°ãƒ«ãƒ¼ãƒ—ã§ï¼‰
function renderBits(containerId, bits, className) {
  const container = document.getElementById(containerId);
  container.innerHTML = '';
  
  // 8ãƒ“ãƒƒãƒˆã”ã¨ã«ã‚°ãƒ«ãƒ¼ãƒ—åŒ–
  for (let i = 0; i < bits.length; i += 8) {
    const group = document.createElement('div');
    group.className = 'bit-group';
    
    for (let j = 0; j < 8 && i + j < bits.length; j++) {
      const span = document.createElement('span');
      span.className = `bit ${className}`;
      span.dataset.index = i + j;
      span.textContent = bits[i + j];
      group.appendChild(span);
    }
    
    container.appendChild(group);
  }
}

// ä»®ã®æš—å·ãƒ“ãƒƒãƒˆã‚’æç”»ï¼ˆ'?'ã§ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€è¡¨ç¤ºï¼‰
function renderPlaceholderCipherBits(length) {
  const container = document.getElementById('cipherBitsContainer');
  container.innerHTML = '';
  
  // 8ãƒ“ãƒƒãƒˆã”ã¨ã«ã‚°ãƒ«ãƒ¼ãƒ—åŒ–
  for (let i = 0; i < length; i += 8) {
    const group = document.createElement('div');
    group.className = 'bit-group';
    
    for (let j = 0; j < 8 && i + j < length; j++) {
      const span = document.createElement('span');
      span.className = 'bit placeholder';
      span.dataset.index = i + j;
      span.textContent = '?';
      group.appendChild(span);
    }
    
    container.appendChild(group);
  }
}

// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®1ã‚¹ãƒ†ãƒƒãƒ—ã‚’å®Ÿè¡Œ
function executeEncryptionStep(index, plainBits, keyBitsInput, cipherBitsInput) {
  if (index >= plainBits.length || index < 0) return;

  // ä»¥å‰ã®ãƒã‚¤ãƒ©ã‚¤ãƒˆã‚’ã‚¯ãƒªã‚¢
  document.querySelectorAll('#plaintextBitsContainer .bit.active').forEach(el => el.classList.remove('active'));
  document.querySelectorAll('#keyBitsContainer .bit.active').forEach(el => el.classList.remove('active'));

  const plainSpan = document.querySelector(`#plaintextBitsContainer .bit[data-index='${index}']`);
  const keySpan = document.querySelector(`#keyBitsContainer .bit[data-index='${index}']`);
  const cipherSpan = document.querySelector(`#cipherBitsContainer .bit[data-index='${index}']`);

  // å‡¦ç†ä¸­ã®ãƒ“ãƒƒãƒˆã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆ
  plainSpan.classList.add('active');
  keySpan.classList.add('active');

  // æš—å·åŒ–å‡¦ç†ã®è¦–è¦šåŠ¹æœ
  if (!keySpan.classList.contains('burn')) {
    setTimeout(() => {
      plainSpan.classList.remove('active');
      keySpan.classList.remove('active');
      keySpan.classList.add('burn');

      cipherSpan.textContent = cipherBitsInput[index];
      cipherSpan.classList.remove('placeholder');
      cipherSpan.classList.add('appear');

      setTimeout(() => {
        keySpan.classList.add('ash');
        setTimeout(() => {
          cipherSpan.classList.remove('appear');
        }, 300);
      }, 500);
    }, 100);
  }

  // é€²æ—ã‚’æ›´æ–°
  updateEncryptProgress(index + 1, plainBits.length);
}

// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å†ç”Ÿå‡¦ç†
function animateEncryption(plainBits, keyBitsInput, cipherBitsInput) {
  // éµã‚„æš—å·ãƒ“ãƒƒãƒˆãŒæœªç”Ÿæˆã®å ´åˆã¯ã€ã“ã“ã§ç”Ÿæˆã™ã‚‹
  if (!keyBitsInput.length || keyBitsInput.length !== plainBits.length) {
    keyBitsInput = generateRandomBits(plainBits.length);
    keyBits = keyBitsInput;
    cipherBitsInput = xorBits(plainBits, keyBitsInput);
    cipherBits = cipherBitsInput;
    renderBits('keyBitsContainer', keyBitsInput, 'key');
    renderPlaceholderCipherBits(plainBits.length);
  }

  // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³çŠ¶æ…‹ã‚’åˆæœŸåŒ–
  encryptAnimationState.isPlaying = true;
  encryptAnimationState.isPaused = false;
  encryptAnimationState.currentIndex = 0;
  encryptAnimationState.totalBits = plainBits.length;

  // ãƒœã‚¿ãƒ³çŠ¶æ…‹ã‚’æ›´æ–°
  document.getElementById('encryptPlayPause').textContent = 'â¸ ä¸€æ™‚åœæ­¢';
  updateEncryptProgress(0, plainBits.length);
  updateEncryptButtonStates();

  function step() {
    if (!encryptAnimationState.isPlaying || encryptAnimationState.isPaused) return;
    if (encryptAnimationState.currentIndex >= plainBits.length) {
      encryptAnimationState.isPlaying = false;
      document.getElementById('encryptPlayPause').textContent = 'â–¶ å†ç”Ÿ';
      updateEncryptButtonStates();
      return;
    }

    executeEncryptionStep(encryptAnimationState.currentIndex, plainBits, keyBitsInput, cipherBitsInput);
    encryptAnimationState.currentIndex++;
    updateEncryptButtonStates();

    encryptAnimationState.timeoutId = setTimeout(step, encryptAnimationState.speed + 600);
  }

  step();
}

// é€²æ—è¡¨ç¤ºã‚’æ›´æ–°
function updateEncryptProgress(current, total) {
  document.getElementById('encryptProgress').textContent = `${current} / ${total}`;
}

// æš—å·åŒ–ãƒœã‚¿ãƒ³ã®çŠ¶æ…‹ã‚’æ›´æ–°
function updateEncryptButtonStates() {
  const keysGenerated = encryptAnimationState.keysGenerated;
  const isPlaying = encryptAnimationState.isPlaying && !encryptAnimationState.isPaused;
  const currentIndex = encryptAnimationState.currentIndex;
  const totalBits = encryptAnimationState.totalBits;
  
  // æš—å·åŒ–é–‹å§‹ãƒœã‚¿ãƒ³
  document.getElementById('startAnimation').disabled = !keysGenerated;
  
  // ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒ‘ãƒãƒ«ã®è¡¨ç¤º/éè¡¨ç¤º
  const controlsPanel = document.getElementById('encryptAnimationControls');
  if (keysGenerated) {
    controlsPanel.style.display = 'flex';
  } else {
    controlsPanel.style.display = 'none';
    return;
  }
  
  // å„ãƒœã‚¿ãƒ³ã®æœ‰åŠ¹/ç„¡åŠ¹çŠ¶æ…‹
  document.getElementById('encryptReset').disabled = false; // éµç”Ÿæˆå¾Œã¯å¸¸ã«æœ‰åŠ¹
  document.getElementById('encryptStepBack').disabled = currentIndex <= 0 || isPlaying;
  document.getElementById('encryptStepForward').disabled = currentIndex >= totalBits || isPlaying;
  document.getElementById('encryptComplete').disabled = currentIndex >= totalBits || isPlaying;
  document.getElementById('encryptSpeed').disabled = false; // å¸¸ã«æœ‰åŠ¹
}


// ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
let plainBits = [];
let keyBits = [];
let cipherBits = [];

// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åˆ¶å¾¡ç”¨å¤‰æ•°
let encryptAnimationState = {
  isPlaying: false,
  isPaused: false,
  currentIndex: 0,
  timeoutId: null,
  totalBits: 0,
  speed: 200,
  keysGenerated: false
};

// å¹³æ–‡ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ å…¥åŠ›å‡¦ç†
document.getElementById('plaintext').addEventListener('input', () => {
  const text = document.getElementById('plaintext').value;
  const { bits, invalidChar } = textToBitsWithValidation(text);
  const errorArea = document.getElementById('errorMessage');

  if (invalidChar) {
    errorArea.textContent = `âŒ ä½¿ç”¨ã§ããªã„æ–‡å­—ãŒã‚ã‚Šã¾ã™ï¼šã€Œ${invalidChar}ã€`;
    renderBits('plaintextBitsContainer', [], 'plain');
    plainBits = [];
    
    // ã‚¨ãƒ©ãƒ¼æ™‚ã¯æš—å·åŒ–çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
    encryptAnimationState.keysGenerated = false;
    encryptAnimationState.currentIndex = 0;
    updateEncryptButtonStates();
  } else {
    errorArea.textContent = '';
    renderBits('plaintextBitsContainer', bits, 'plain');
    plainBits = bits;
    
    // å¹³æ–‡ãŒå¤‰æ›´ã•ã‚ŒãŸã‚‰æš—å·åŒ–çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
    encryptAnimationState.keysGenerated = false;
    encryptAnimationState.currentIndex = 0;
    updateEncryptButtonStates();
  }
});

// éµç”Ÿæˆãƒœã‚¿ãƒ³
document.getElementById('generateKey').addEventListener('click', () => {
  const plainText = document.getElementById('plaintext').value;
  const { bits, invalidChar } = textToBitsWithValidation(plainText);
  const errorArea = document.getElementById('errorMessage');

  if (invalidChar) {
    errorArea.textContent = `âŒ ä½¿ç”¨ã§ããªã„æ–‡å­—ãŒã‚ã‚Šã¾ã™ï¼šã€Œ${invalidChar}ã€`;
    renderBits('plaintextBitsContainer', [], 'plain');
    renderBits('keyBitsContainer', [], 'key');
    renderBits('cipherBitsContainer', [], 'cipher');
    plainBits = [];
    keyBits = [];
    cipherBits = [];
    return;
  }

  errorArea.textContent = '';
  plainBits = bits;
  keyBits = generateRandomBits(plainBits.length);
  cipherBits = xorBits(plainBits, keyBits);

  renderBits('plaintextBitsContainer', plainBits, 'plain');
  renderBits('keyBitsContainer', keyBits, 'key');
  renderPlaceholderCipherBits(plainBits.length);
  
  // æš—å·åŒ–çŠ¶æ…‹ã‚’æ›´æ–°
  encryptAnimationState.keysGenerated = true;
  encryptAnimationState.totalBits = plainBits.length;
  encryptAnimationState.currentIndex = 0;
  updateEncryptButtonStates();
  updateEncryptProgress(0, plainBits.length);
});

// ğŸ”˜ æš—å·åŒ–é–‹å§‹ãƒœã‚¿ãƒ³
document.getElementById('startAnimation').addEventListener('click', () => {
  if (!plainBits.length || !keyBits.length || !cipherBits.length) return;
  
  // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ãƒªã‚»ãƒƒãƒˆ
  resetEncryptionAnimation();
  animateEncryption(plainBits, keyBits, cipherBits);
});

// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©
function setupEncryptionControls() {
  // å†ç”Ÿ/ä¸€æ™‚åœæ­¢ãƒœã‚¿ãƒ³
  document.getElementById('encryptPlayPause').addEventListener('click', () => {
    if (encryptAnimationState.isPlaying && !encryptAnimationState.isPaused) {
      // ä¸€æ™‚åœæ­¢
      encryptAnimationState.isPaused = true;
      document.getElementById('encryptPlayPause').textContent = 'â–¶ å†ç”Ÿ';
      clearTimeout(encryptAnimationState.timeoutId);
      updateEncryptButtonStates();
    } else if (encryptAnimationState.isPaused) {
      // å†é–‹
      encryptAnimationState.isPaused = false;
      document.getElementById('encryptPlayPause').textContent = 'â¸ ä¸€æ™‚åœæ­¢';
      updateEncryptButtonStates();
      
      function step() {
        if (!encryptAnimationState.isPlaying || encryptAnimationState.isPaused) return;
        if (encryptAnimationState.currentIndex >= plainBits.length) {
          encryptAnimationState.isPlaying = false;
          document.getElementById('encryptPlayPause').textContent = 'â–¶ å†ç”Ÿ';
          updateEncryptButtonStates();
          return;
        }

        executeEncryptionStep(encryptAnimationState.currentIndex, plainBits, keyBits, cipherBits);
        encryptAnimationState.currentIndex++;
        updateEncryptButtonStates();

        encryptAnimationState.timeoutId = setTimeout(step, encryptAnimationState.speed + 600);
      }
      step();
    } else {
      // æœ€åˆã‹ã‚‰å†ç”Ÿ
      resetEncryptionAnimation();
      animateEncryption(plainBits, keyBits, cipherBits);
    }
  });

  // 1ã¤æˆ»ã‚‹ãƒœã‚¿ãƒ³
  document.getElementById('encryptStepBack').addEventListener('click', () => {
    if (encryptAnimationState.currentIndex > 0) {
      encryptAnimationState.currentIndex--;
      
      // ä¸€æ™‚åœæ­¢çŠ¶æ…‹ã«ã™ã‚‹
      encryptAnimationState.isPaused = true;
      document.getElementById('encryptPlayPause').textContent = 'â–¶ å†ç”Ÿ';
      clearTimeout(encryptAnimationState.timeoutId);
      
      // ãƒ“ãƒƒãƒˆã®çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¦ã‹ã‚‰æŒ‡å®šä½ç½®ã¾ã§å†ç¾
      resetBitStates();
      for (let i = 0; i < encryptAnimationState.currentIndex; i++) {
        executeSilentStep(i, plainBits, keyBits, cipherBits);
      }
      
      // ç¾åœ¨ã®ã‚¹ãƒ†ãƒƒãƒ—ã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆ
      if (encryptAnimationState.currentIndex > 0) {
        const index = encryptAnimationState.currentIndex - 1;
        const plainSpan = document.querySelector(`#plaintextBitsContainer .bit[data-index='${index}']`);
        const keySpan = document.querySelector(`#keyBitsContainer .bit[data-index='${index}']`);
        plainSpan.classList.add('active');
        keySpan.classList.add('active');
      }
      
      updateEncryptProgress(encryptAnimationState.currentIndex, plainBits.length);
      updateEncryptButtonStates();
    }
  });

  // 1ã¤é€²ã‚€ãƒœã‚¿ãƒ³
  document.getElementById('encryptStepForward').addEventListener('click', () => {
    if (encryptAnimationState.currentIndex < plainBits.length) {
      // ä¸€æ™‚åœæ­¢çŠ¶æ…‹ã«ã™ã‚‹
      encryptAnimationState.isPaused = true;
      document.getElementById('encryptPlayPause').textContent = 'â–¶ å†ç”Ÿ';
      clearTimeout(encryptAnimationState.timeoutId);
      
      executeEncryptionStep(encryptAnimationState.currentIndex, plainBits, keyBits, cipherBits);
      encryptAnimationState.currentIndex++;
      updateEncryptButtonStates();
    }
  });

  // ãƒªã‚»ãƒƒãƒˆãƒœã‚¿ãƒ³
  document.getElementById('encryptReset').addEventListener('click', () => {
    clearTimeout(encryptAnimationState.timeoutId);
    encryptAnimationState.isPlaying = false;
    encryptAnimationState.isPaused = false;
    encryptAnimationState.currentIndex = 0;
    
    document.getElementById('encryptPlayPause').textContent = 'â¸ ä¸€æ™‚åœæ­¢';
    
    resetBitStates();
    updateEncryptProgress(0, plainBits.length);
    updateEncryptButtonStates();
  });

  // å…¨å‡¦ç†ãƒœã‚¿ãƒ³
  document.getElementById('encryptComplete').addEventListener('click', () => {
    clearTimeout(encryptAnimationState.timeoutId);
    encryptAnimationState.isPlaying = false;
    encryptAnimationState.isPaused = true;
    document.getElementById('encryptPlayPause').textContent = 'â–¶ å†ç”Ÿ';
    
    // ã™ã¹ã¦ã®ã‚¹ãƒ†ãƒƒãƒ—ã‚’ä¸€æ°—ã«å®Ÿè¡Œ
    resetBitStates();
    for (let i = 0; i < plainBits.length; i++) {
      executeSilentStep(i, plainBits, keyBits, cipherBits);
    }
    
    encryptAnimationState.currentIndex = plainBits.length;
    updateEncryptProgress(plainBits.length, plainBits.length);
    updateEncryptButtonStates();
  });

  // ã‚¹ãƒ”ãƒ¼ãƒ‰é¸æŠ
  document.getElementById('encryptSpeed').addEventListener('change', (e) => {
    encryptAnimationState.speed = parseInt(e.target.value);
  });
}

// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ãƒªã‚»ãƒƒãƒˆ
function resetEncryptionAnimation() {
  clearTimeout(encryptAnimationState.timeoutId);
  encryptAnimationState.isPlaying = false;
  encryptAnimationState.isPaused = false;
  encryptAnimationState.currentIndex = 0;
  
  // ãƒ“ãƒƒãƒˆã®çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
  resetBitStates();
}

// ãƒ“ãƒƒãƒˆã®è¦–è¦šçŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
function resetBitStates() {
  // ã™ã¹ã¦ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–çŠ¶æ…‹ã‚’è§£é™¤
  document.querySelectorAll('.bit.active').forEach(el => el.classList.remove('active'));
  
  // éµãƒ“ãƒƒãƒˆã‚’ãƒªã‚»ãƒƒãƒˆ
  document.querySelectorAll('#keyBitsContainer .bit').forEach(el => {
    el.classList.remove('burn', 'ash');
  });
  
  // æš—å·ãƒ“ãƒƒãƒˆã‚’ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼ã«æˆ»ã™
  renderPlaceholderCipherBits(plainBits.length);
}

// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãªã—ã§ã‚¹ãƒ†ãƒƒãƒ—ã‚’å®Ÿè¡Œï¼ˆæˆ»ã‚‹æ™‚ç”¨ï¼‰
function executeSilentStep(index, plainBits, keyBitsInput, cipherBitsInput) {
  const keySpan = document.querySelector(`#keyBitsContainer .bit[data-index='${index}']`);
  const cipherSpan = document.querySelector(`#cipherBitsContainer .bit[data-index='${index}']`);
  
  keySpan.classList.add('burn', 'ash');
  cipherSpan.textContent = cipherBitsInput[index];
  cipherSpan.classList.remove('placeholder');
}

// ã‚¿ãƒ–åˆ‡ã‚Šæ›¿ãˆæ©Ÿèƒ½
function setupTabs() {
  const tabButtons = document.querySelectorAll('.tab-button');
  const tabPanels = document.querySelectorAll('.tab-panel');

  tabButtons.forEach(button => {
    button.addEventListener('click', () => {
      const targetTab = button.getAttribute('data-tab');

      // ã™ã¹ã¦ã®ã‚¿ãƒ–ãƒœã‚¿ãƒ³ã¨ãƒ‘ãƒãƒ«ã®éã‚¢ã‚¯ãƒ†ã‚£ãƒ–åŒ–
      tabButtons.forEach(btn => btn.classList.remove('active'));
      tabPanels.forEach(panel => panel.classList.remove('active'));

      // ã‚¯ãƒªãƒƒã‚¯ã•ã‚ŒãŸã‚¿ãƒ–ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–åŒ–
      button.classList.add('active');
      document.getElementById(`${targetTab}-tab`).classList.add('active');
    });
  });
}

// å¾©å·ç”¨ã®ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
let cipherTextBits = [];
let decryptKeyBits = [];
let decryptedTextBits = [];

// å¾©å·ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åˆ¶å¾¡ç”¨å¤‰æ•°
let decryptAnimationState = {
  isPlaying: false,
  isPaused: false,
  currentIndex: 0,
  timeoutId: null,
  totalBits: 0,
  speed: 200,
  keysGenerated: false
};

// å¾©å·ãƒœã‚¿ãƒ³ã®çŠ¶æ…‹ã‚’æ›´æ–°
function updateDecryptButtonStates() {
  const keysGenerated = decryptAnimationState.keysGenerated;
  const isPlaying = decryptAnimationState.isPlaying && !decryptAnimationState.isPaused;
  const currentIndex = decryptAnimationState.currentIndex;
  const totalBits = decryptAnimationState.totalBits;
  
  // å¾©å·é–‹å§‹ãƒœã‚¿ãƒ³
  document.getElementById('startDecryption').disabled = !keysGenerated;
  
  // ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒ‘ãƒãƒ«ã®è¡¨ç¤º/éè¡¨ç¤º
  const controlsPanel = document.getElementById('decryptAnimationControls');
  if (keysGenerated) {
    controlsPanel.style.display = 'flex';
  } else {
    controlsPanel.style.display = 'none';
    return;
  }
  
  // å„ãƒœã‚¿ãƒ³ã®æœ‰åŠ¹/ç„¡åŠ¹çŠ¶æ…‹
  document.getElementById('decryptReset').disabled = false;
  document.getElementById('decryptStepBack').disabled = currentIndex <= 0 || isPlaying;
  document.getElementById('decryptStepForward').disabled = currentIndex >= totalBits || isPlaying;
  document.getElementById('decryptComplete').disabled = currentIndex >= totalBits || isPlaying;
  document.getElementById('decryptSpeed').disabled = false;
}

// å¾©å·ã‚¿ãƒ–ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©
function setupDecryptionHandlers() {
  // æš—å·åŒ–çµæœã‚’åæ˜ ãƒœã‚¿ãƒ³
  document.getElementById('copyFromEncryption').addEventListener('click', () => {
    // æš—å·åŒ–ãŒå®Œäº†ã—ã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
    if (!cipherBits.length || !keyBits.length) {
      alert('ã¾ãšæš—å·åŒ–ã‚¿ãƒ–ã§æš—å·åŒ–ã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„ã€‚');
      return;
    }

    // ãƒ“ãƒƒãƒˆåˆ—ã‚’æ–‡å­—åˆ—ã«å¤‰æ›
    const cipherText = bitsToText(cipherBits);
    const keyText = bitsToText(keyBits);

    // å¾©å·ã‚¿ãƒ–ã®å…¥åŠ›æ¬„ã«è¨­å®š
    document.getElementById('ciphertext').value = cipherText;
    
    // ãƒ“ãƒƒãƒˆè¡¨ç¤ºã‚’æ›´æ–°
    cipherTextBits = [...cipherBits];
    decryptKeyBits = [...keyBits];
    decryptedTextBits = xorBits(cipherTextBits, decryptKeyBits);
    
    renderBits('ciphertextBitsContainer', cipherTextBits, 'cipher');
    renderBits('decryptKeyBitsContainer', decryptKeyBits, 'key');
    renderPlaceholderDecryptedBits(cipherTextBits.length);
    
    // ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ã‚¯ãƒªã‚¢
    document.getElementById('decryptErrorMessage').textContent = '';
    
    // å¾©å·çŠ¶æ…‹ã‚’æ›´æ–°
    decryptAnimationState.keysGenerated = true;
    decryptAnimationState.totalBits = cipherTextBits.length;
    decryptAnimationState.currentIndex = 0;
    updateDecryptButtonStates();
  });

  // æš—å·æ–‡ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ å…¥åŠ›å‡¦ç†
  document.getElementById('ciphertext').addEventListener('input', () => {
    const text = document.getElementById('ciphertext').value;
    const { bits, invalidChar } = textToBitsWithValidation(text);
    const errorArea = document.getElementById('decryptErrorMessage');

    if (invalidChar) {
      errorArea.textContent = `âŒ ä½¿ç”¨ã§ããªã„æ–‡å­—ãŒã‚ã‚Šã¾ã™ï¼šã€Œ${invalidChar}ã€`;
      renderBits('ciphertextBitsContainer', [], 'cipher');
      cipherTextBits = [];
    } else {
      errorArea.textContent = '';
      renderBits('ciphertextBitsContainer', bits, 'cipher');
      cipherTextBits = bits;
      
      // æš—å·æ–‡ãŒå¤‰æ›´ã•ã‚ŒãŸã‚‰å¾©å·çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
      decryptAnimationState.keysGenerated = false;
      decryptAnimationState.currentIndex = 0;
      updateDecryptButtonStates();
    }
  });

  // éµå…¥åŠ›ãƒœã‚¿ãƒ³ï¼ˆã“ã“ã§ã¯æš—å·åŒ–ã¨åŒã˜ãƒ©ãƒ³ãƒ€ãƒ ç”Ÿæˆã‚’ä½¿ç”¨ï¼‰
  document.getElementById('generateDecryptKey').addEventListener('click', () => {
    const cipherText = document.getElementById('ciphertext').value;
    const { bits, invalidChar } = textToBitsWithValidation(cipherText);
    const errorArea = document.getElementById('decryptErrorMessage');

    if (invalidChar) {
      errorArea.textContent = `âŒ ä½¿ç”¨ã§ããªã„æ–‡å­—ãŒã‚ã‚Šã¾ã™ï¼šã€Œ${invalidChar}ã€`;
      renderBits('ciphertextBitsContainer', [], 'cipher');
      renderBits('decryptKeyBitsContainer', [], 'key');
      renderBits('decryptedBitsContainer', [], 'plain');
      cipherTextBits = [];
      decryptKeyBits = [];
      decryptedTextBits = [];
      return;
    }

    errorArea.textContent = '';
    cipherTextBits = bits;
    decryptKeyBits = generateRandomBits(cipherTextBits.length);
    decryptedTextBits = xorBits(cipherTextBits, decryptKeyBits);

    renderBits('ciphertextBitsContainer', cipherTextBits, 'cipher');
    renderBits('decryptKeyBitsContainer', decryptKeyBits, 'key');
    renderPlaceholderDecryptedBits(cipherTextBits.length);
    
    // å¾©å·çŠ¶æ…‹ã‚’æ›´æ–°
    decryptAnimationState.keysGenerated = true;
    decryptAnimationState.totalBits = cipherTextBits.length;
    decryptAnimationState.currentIndex = 0;
    updateDecryptButtonStates();
  });

  // å¾©å·é–‹å§‹ãƒœã‚¿ãƒ³
  document.getElementById('startDecryption').addEventListener('click', () => {
    if (!cipherTextBits.length || !decryptKeyBits.length || !decryptedTextBits.length) return;
    animateDecryption(cipherTextBits, decryptKeyBits, decryptedTextBits);
  });
}

// å¾©å·ãƒ“ãƒƒãƒˆã®ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼è¡¨ç¤º
function renderPlaceholderDecryptedBits(length) {
  const container = document.getElementById('decryptedBitsContainer');
  container.innerHTML = '';
  
  // 8ãƒ“ãƒƒãƒˆã”ã¨ã«ã‚°ãƒ«ãƒ¼ãƒ—åŒ–
  for (let i = 0; i < length; i += 8) {
    const group = document.createElement('div');
    group.className = 'bit-group';
    
    for (let j = 0; j < 8 && i + j < length; j++) {
      const span = document.createElement('span');
      span.className = 'bit placeholder';
      span.dataset.index = i + j;
      span.textContent = '?';
      group.appendChild(span);
    }
    
    container.appendChild(group);
  }
}

// å¾©å·ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
function animateDecryption(cipherBits, keyBitsInput, decryptedBitsInput) {
  if (!keyBitsInput.length || keyBitsInput.length !== cipherBits.length) {
    keyBitsInput = generateRandomBits(cipherBits.length);
    decryptKeyBits = keyBitsInput;
    decryptedBitsInput = xorBits(cipherBits, keyBitsInput);
    decryptedTextBits = decryptedBitsInput;
    renderBits('decryptKeyBitsContainer', keyBitsInput, 'key');
    renderPlaceholderDecryptedBits(cipherBits.length);
  }

  let index = 0;

  function step() {
    if (index >= cipherBits.length) return;

    const cipherSpan = document.querySelector(`#ciphertextBitsContainer .bit[data-index='${index}']`);
    const keySpan = document.querySelector(`#decryptKeyBitsContainer .bit[data-index='${index}']`);
    const decryptedSpan = document.querySelector(`#decryptedBitsContainer .bit[data-index='${index}']`);

    // å‡¦ç†ä¸­ã®ãƒ“ãƒƒãƒˆã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆ
    cipherSpan.classList.add('active');
    keySpan.classList.add('active');

    setTimeout(() => {
      cipherSpan.classList.remove('active');
      keySpan.classList.remove('active');
      keySpan.classList.add('burn');

      decryptedSpan.textContent = decryptedBitsInput[index];
      decryptedSpan.classList.remove('placeholder');
      decryptedSpan.classList.add('appear');

      setTimeout(() => {
        keySpan.classList.add('ash');
        // å¾©å·ãƒ“ãƒƒãƒˆã®å…‰ã‚’æ¶ˆã™
        setTimeout(() => {
          decryptedSpan.classList.remove('appear');
        }, 300);
      }, 500);

      index++;
      setTimeout(step, 150);
    }, 100);
  }

  step();
}

// åˆæœŸè¡¨ç¤ºã§HELLOã®ãƒ“ãƒƒãƒˆã‚’åæ˜ 
// å¾©å·ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ï¼ˆç°¡ç•¥ç‰ˆï¼‰
function setupDecryptionControls() {
  // ã‚¹ãƒ”ãƒ¼ãƒ‰é¸æŠ
  document.getElementById('decryptSpeed').addEventListener('change', (e) => {
    decryptAnimationState.speed = parseInt(e.target.value);
  });
  
  // ç°¡å˜ãªãƒªã‚»ãƒƒãƒˆæ©Ÿèƒ½
  document.getElementById('decryptReset').addEventListener('click', () => {
    decryptAnimationState.currentIndex = 0;
    updateDecryptButtonStates();
  });
}

window.addEventListener('DOMContentLoaded', () => {
  setupTabs();
  setupDecryptionHandlers();
  setupEncryptionControls();
  setupDecryptionControls();

  const input = document.getElementById('plaintext');
  const text = input.value;
  const { bits, invalidChar } = textToBitsWithValidation(text);
  const errorArea = document.getElementById('errorMessage');

  if (invalidChar) {
    errorArea.textContent = `âŒ ä½¿ç”¨ã§ããªã„æ–‡å­—ãŒã‚ã‚Šã¾ã™ï¼šã€Œ${invalidChar}ã€`;
    renderBits('plaintextBitsContainer', [], 'plain');
    return;
  }

  errorArea.textContent = '';
  plainBits = bits;
  renderBits('plaintextBitsContainer', plainBits, 'plain');
  
  // åˆæœŸçŠ¶æ…‹ã§ãƒœã‚¿ãƒ³çŠ¶æ…‹ã‚’æ›´æ–°
  updateEncryptButtonStates();
  updateDecryptButtonStates();
});
